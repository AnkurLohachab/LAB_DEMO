{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-95720882c523173cd13f8c831f71d92acfbe63f2",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/EscrowManager.sol": "project/contracts/EscrowManager.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "prague",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/EscrowManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\n/**\n * @title EscrowManager\n * @dev Advanced escrow with dispute resolution\n */\ncontract EscrowManager {\n    IERC20 public token;\n    address public owner;\n    address public arbiter;\n    bool public paused;\n    \n    enum EscrowStatus { Active, Released, Refunded, Disputed }\n    \n    struct Escrow {\n        uint256 id;\n        address depositor;\n        address beneficiary;\n        uint256 amount;\n        uint256 createdAt;\n        uint256 timeoutDuration;\n        EscrowStatus status;\n        string purpose;\n    }\n    \n    uint256 public nextEscrowId = 1;\n    mapping(uint256 => Escrow) public escrows;\n    mapping(address => uint256[]) public depositorEscrows;\n    mapping(address => uint256[]) public beneficiaryEscrows;\n    \n    event EscrowCreated(uint256 indexed escrowId, address indexed depositor, address indexed beneficiary, uint256 amount);\n    event EscrowReleased(uint256 indexed escrowId, address indexed beneficiary, uint256 amount);\n    event EscrowRefunded(uint256 indexed escrowId, address indexed depositor, uint256 amount);\n    event EscrowDisputed(uint256 indexed escrowId);\n    event DisputeResolved(uint256 indexed escrowId, address winner);\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the owner\");\n        _;\n    }\n    \n    modifier onlyArbiter() {\n        require(msg.sender == arbiter, \"Not the arbiter\");\n        _;\n    }\n    \n    modifier whenNotPaused() {\n        require(!paused, \"Contract is paused\");\n        _;\n    }\n    \n    constructor(address _tokenAddress) {\n        token = IERC20(_tokenAddress);\n        owner = msg.sender;\n        arbiter = msg.sender;\n    }\n    \n    /**\n     * @dev Create new escrow\n     */\n    function createEscrow(\n        address beneficiary,\n        uint256 amount,\n        uint256 timeoutDuration,\n        string memory purpose\n    ) public whenNotPaused returns (uint256) {\n        require(beneficiary != address(0), \"Invalid beneficiary\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(timeoutDuration >= 1 days, \"Timeout must be at least 1 day\");\n        \n        require(\n            token.transferFrom(msg.sender, address(this), amount),\n            \"Token transfer failed\"\n        );\n        \n        uint256 escrowId = nextEscrowId++;\n        \n        escrows[escrowId] = Escrow({\n            id: escrowId,\n            depositor: msg.sender,\n            beneficiary: beneficiary,\n            amount: amount,\n            createdAt: block.timestamp,\n            timeoutDuration: timeoutDuration,\n            status: EscrowStatus.Active,\n            purpose: purpose\n        });\n        \n        depositorEscrows[msg.sender].push(escrowId);\n        beneficiaryEscrows[beneficiary].push(escrowId);\n        \n        emit EscrowCreated(escrowId, msg.sender, beneficiary, amount);\n        \n        return escrowId;\n    }\n    \n    /**\n     * @dev Release escrow to beneficiary\n     */\n    function releaseEscrow(uint256 escrowId) public whenNotPaused {\n        Escrow storage escrow = escrows[escrowId];\n        require(escrow.depositor == msg.sender, \"Not the depositor\");\n        require(escrow.status == EscrowStatus.Active, \"Escrow not active\");\n        \n        escrow.status = EscrowStatus.Released;\n        \n        require(\n            token.transfer(escrow.beneficiary, escrow.amount),\n            \"Token transfer failed\"\n        );\n        \n        emit EscrowReleased(escrowId, escrow.beneficiary, escrow.amount);\n    }\n    \n    /**\n     * @dev Refund escrow to depositor\n     */\n    function refundEscrow(uint256 escrowId) public whenNotPaused {\n        Escrow storage escrow = escrows[escrowId];\n        require(\n            escrow.depositor == msg.sender || escrow.beneficiary == msg.sender,\n            \"Not authorized\"\n        );\n        require(escrow.status == EscrowStatus.Active, \"Escrow not active\");\n        \n        escrow.status = EscrowStatus.Refunded;\n        \n        require(\n            token.transfer(escrow.depositor, escrow.amount),\n            \"Token transfer failed\"\n        );\n        \n        emit EscrowRefunded(escrowId, escrow.depositor, escrow.amount);\n    }\n    \n    /**\n     * @dev Claim refund after timeout\n     */\n    function claimTimeout(uint256 escrowId) public whenNotPaused {\n        Escrow storage escrow = escrows[escrowId];\n        require(escrow.depositor == msg.sender, \"Not the depositor\");\n        require(escrow.status == EscrowStatus.Active, \"Escrow not active\");\n        require(\n            block.timestamp >= escrow.createdAt + escrow.timeoutDuration,\n            \"Timeout not reached\"\n        );\n        \n        escrow.status = EscrowStatus.Refunded;\n        \n        require(\n            token.transfer(escrow.depositor, escrow.amount),\n            \"Token transfer failed\"\n        );\n        \n        emit EscrowRefunded(escrowId, escrow.depositor, escrow.amount);\n    }\n    \n    /**\n     * @dev Raise dispute\n     */\n    function raiseDispute(uint256 escrowId) public {\n        Escrow storage escrow = escrows[escrowId];\n        require(\n            escrow.depositor == msg.sender || escrow.beneficiary == msg.sender,\n            \"Not a party to this escrow\"\n        );\n        require(escrow.status == EscrowStatus.Active, \"Escrow not active\");\n        \n        escrow.status = EscrowStatus.Disputed;\n        \n        emit EscrowDisputed(escrowId);\n    }\n    \n    /**\n     * @dev Resolve dispute (arbiter only)\n     */\n    function resolveDispute(uint256 escrowId, bool releaseToBeneficiary) public onlyArbiter {\n        Escrow storage escrow = escrows[escrowId];\n        require(escrow.status == EscrowStatus.Disputed, \"Not disputed\");\n        \n        address winner;\n        \n        if (releaseToBeneficiary) {\n            escrow.status = EscrowStatus.Released;\n            winner = escrow.beneficiary;\n            require(\n                token.transfer(escrow.beneficiary, escrow.amount),\n                \"Token transfer failed\"\n            );\n            emit EscrowReleased(escrowId, escrow.beneficiary, escrow.amount);\n        } else {\n            escrow.status = EscrowStatus.Refunded;\n            winner = escrow.depositor;\n            require(\n                token.transfer(escrow.depositor, escrow.amount),\n                \"Token transfer failed\"\n            );\n            emit EscrowRefunded(escrowId, escrow.depositor, escrow.amount);\n        }\n        \n        emit DisputeResolved(escrowId, winner);\n    }\n    \n    /**\n     * @dev Get escrow details\n     */\n    function getEscrow(uint256 escrowId) public view returns (\n        address depositor,\n        address beneficiary,\n        uint256 amount,\n        EscrowStatus status,\n        uint256 createdAt,\n        uint256 timeoutDuration,\n        string memory purpose\n    ) {\n        Escrow memory escrow = escrows[escrowId];\n        return (\n            escrow.depositor,\n            escrow.beneficiary,\n            escrow.amount,\n            escrow.status,\n            escrow.createdAt,\n            escrow.timeoutDuration,\n            escrow.purpose\n        );\n    }\n    \n    /**\n     * @dev Get escrows by depositor\n     */\n    function getDepositorEscrows(address depositor) public view returns (uint256[] memory) {\n        return depositorEscrows[depositor];\n    }\n    \n    /**\n     * @dev Get escrows by beneficiary\n     */\n    function getBeneficiaryEscrows(address beneficiary) public view returns (uint256[] memory) {\n        return beneficiaryEscrows[beneficiary];\n    }\n    \n    /**\n     * @dev Set arbiter\n     */\n    function setArbiter(address newArbiter) public onlyOwner {\n        require(newArbiter != address(0), \"Invalid arbiter address\");\n        arbiter = newArbiter;\n    }\n    \n    /**\n     * @dev Pause contract\n     */\n    function pause() public onlyOwner {\n        paused = true;\n    }\n    \n    /**\n     * @dev Unpause contract\n     */\n    function unpause() public onlyOwner {\n        paused = false;\n    }\n}\n"
      }
    }
  }
}