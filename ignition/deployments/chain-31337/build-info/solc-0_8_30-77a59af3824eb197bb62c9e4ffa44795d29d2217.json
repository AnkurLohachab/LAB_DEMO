{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-77a59af3824eb197bb62c9e4ffa44795d29d2217",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/BountyBoard.sol": "project/contracts/BountyBoard.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "prague",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/BountyBoard.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface IERC721 {\n    function issueBadge(address student, uint8 category, string memory achievement) external returns (uint256);\n    function getCategoryCount(address student, uint8 category) external view returns (uint256);\n}\n\n/**\n * @title BountyBoard\n * @dev Main contract for posting and completing bounties\n */\ncontract BountyBoard {\n    IERC20 public bountyToken;\n    IERC721 public reputationNFT;\n    address public owner;\n    \n    enum Category { Math, Programming, Writing, Science, Language }\n    enum Status { Open, Claimed, Submitted, Completed, Cancelled }\n    \n    struct Bounty {\n        uint256 id;\n        address requester;\n        address helper;\n        string description;\n        uint256 reward;\n        Category category;\n        Status status;\n        uint256 createdAt;\n        string submissionUrl;\n    }\n    \n    uint256 public nextBountyId = 1;\n    mapping(uint256 => Bounty) public bounties;\n    mapping(address => uint256[]) public userBounties;\n    mapping(address => uint256[]) public helperBounties;\n    \n    event BountyCreated(uint256 indexed bountyId, address indexed requester, uint256 reward, Category category);\n    event BountyClaimed(uint256 indexed bountyId, address indexed helper);\n    event BountySubmitted(uint256 indexed bountyId, string submissionUrl);\n    event BountyCompleted(uint256 indexed bountyId, address indexed helper, uint256 reward);\n    event BountyCancelled(uint256 indexed bountyId);\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the owner\");\n        _;\n    }\n    \n    constructor(address _tokenAddress, address _nftAddress) {\n        bountyToken = IERC20(_tokenAddress);\n        reputationNFT = IERC721(_nftAddress);\n        owner = msg.sender;\n    }\n    \n    /**\n     * @dev Create a new bounty\n     */\n    function createBounty(\n        string memory description,\n        uint256 reward,\n        Category category\n    ) public returns (uint256) {\n        require(bytes(description).length > 0, \"Description required\");\n        require(reward > 0, \"Reward must be greater than 0\");\n        \n        // Transfer tokens from requester to this contract (escrow)\n        require(\n            bountyToken.transferFrom(msg.sender, address(this), reward),\n            \"Token transfer failed\"\n        );\n        \n        uint256 bountyId = nextBountyId++;\n        \n        bounties[bountyId] = Bounty({\n            id: bountyId,\n            requester: msg.sender,\n            helper: address(0),\n            description: description,\n            reward: reward,\n            category: category,\n            status: Status.Open,\n            createdAt: block.timestamp,\n            submissionUrl: \"\"\n        });\n        \n        userBounties[msg.sender].push(bountyId);\n        \n        emit BountyCreated(bountyId, msg.sender, reward, category);\n        \n        return bountyId;\n    }\n    \n    /**\n     * @dev Claim an open bounty\n     */\n    function claimBounty(uint256 bountyId) public {\n        Bounty storage bounty = bounties[bountyId];\n        require(bounty.status == Status.Open, \"Bounty not open\");\n        require(bounty.requester != msg.sender, \"Cannot claim own bounty\");\n        \n        bounty.helper = msg.sender;\n        bounty.status = Status.Claimed;\n        \n        helperBounties[msg.sender].push(bountyId);\n        \n        emit BountyClaimed(bountyId, msg.sender);\n    }\n    \n    /**\n     * @dev Submit solution for a claimed bounty\n     */\n    function submitSolution(uint256 bountyId, string memory submissionUrl) public {\n        Bounty storage bounty = bounties[bountyId];\n        require(bounty.helper == msg.sender, \"Not the assigned helper\");\n        require(bounty.status == Status.Claimed, \"Bounty not in claimed state\");\n        require(bytes(submissionUrl).length > 0, \"Submission URL required\");\n        \n        bounty.submissionUrl = submissionUrl;\n        bounty.status = Status.Submitted;\n        \n        emit BountySubmitted(bountyId, submissionUrl);\n    }\n    \n    /**\n     * @dev Approve solution and release payment\n     */\n    function approveSolution(uint256 bountyId) public {\n        Bounty storage bounty = bounties[bountyId];\n        require(bounty.requester == msg.sender, \"Not the requester\");\n        require(bounty.status == Status.Submitted, \"No solution submitted\");\n        \n        bounty.status = Status.Completed;\n        \n        // Release payment to helper\n        require(\n            bountyToken.transfer(bounty.helper, bounty.reward),\n            \"Payment transfer failed\"\n        );\n        \n        // Issue reputation badge\n        string memory achievement = string(abi.encodePacked(\n            \"Completed bounty: \",\n            bounty.description\n        ));\n        \n        reputationNFT.issueBadge(\n            bounty.helper,\n            uint8(bounty.category),\n            achievement\n        );\n        \n        emit BountyCompleted(bountyId, bounty.helper, bounty.reward);\n    }\n    \n    /**\n     * @dev Reject solution and return to claimed state\n     */\n    function rejectSolution(uint256 bountyId, string memory reason) public {\n        Bounty storage bounty = bounties[bountyId];\n        require(bounty.requester == msg.sender, \"Not the requester\");\n        require(bounty.status == Status.Submitted, \"No solution submitted\");\n        require(bytes(reason).length > 0, \"Rejection reason required\");\n        \n        bounty.status = Status.Claimed;\n        bounty.submissionUrl = \"\";\n    }\n    \n    /**\n     * @dev Cancel bounty and refund requester\n     */\n    function cancelBounty(uint256 bountyId) public {\n        Bounty storage bounty = bounties[bountyId];\n        require(bounty.requester == msg.sender, \"Not the requester\");\n        require(bounty.status == Status.Open, \"Can only cancel open bounties\");\n        \n        bounty.status = Status.Cancelled;\n        \n        // Refund tokens to requester\n        require(\n            bountyToken.transfer(bounty.requester, bounty.reward),\n            \"Refund transfer failed\"\n        );\n        \n        emit BountyCancelled(bountyId);\n    }\n    \n    /**\n     * @dev Get bounty details\n     */\n    function getBounty(uint256 bountyId) public view returns (\n        address requester,\n        address helper,\n        string memory description,\n        uint256 reward,\n        Category category,\n        Status status,\n        string memory submissionUrl\n    ) {\n        Bounty memory bounty = bounties[bountyId];\n        return (\n            bounty.requester,\n            bounty.helper,\n            bounty.description,\n            bounty.reward,\n            bounty.category,\n            bounty.status,\n            bounty.submissionUrl\n        );\n    }\n    \n    /**\n     * @dev Get all bounties created by a user\n     */\n    function getUserBounties(address user) public view returns (uint256[] memory) {\n        return userBounties[user];\n    }\n    \n    /**\n     * @dev Get all bounties claimed by a helper\n     */\n    function getHelperBounties(address helper) public view returns (uint256[] memory) {\n        return helperBounties[helper];\n    }\n    \n    /**\n     * @dev Get all open bounties\n     */\n    function getOpenBounties() public view returns (uint256[] memory) {\n        uint256 count = 0;\n        for (uint256 i = 1; i < nextBountyId; i++) {\n            if (bounties[i].status == Status.Open) {\n                count++;\n            }\n        }\n        \n        uint256[] memory openBounties = new uint256[](count);\n        uint256 index = 0;\n        for (uint256 i = 1; i < nextBountyId; i++) {\n            if (bounties[i].status == Status.Open) {\n                openBounties[index] = i;\n                index++;\n            }\n        }\n        \n        return openBounties;\n    }\n    \n    /**\n     * @dev Get contract token balance (total escrow)\n     */\n    function getEscrowBalance() public view returns (uint256) {\n        return bountyToken.balanceOf(address(this));\n    }\n}\n"
      }
    }
  }
}